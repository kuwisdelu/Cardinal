
%\VignetteIndexEntry{Cardinal: Tools for mass spectrometry imaging}
%\VignetteKeyword{Infrastructure, Bioinformatics, Proteomics, MassSpectrometry, Clustering, Classification}

\documentclass[a4paper]{article}

<<eval=TRUE, echo=FALSE, results=tex>>=
BiocStyle::latex()
@

\title{Cardinal: Analytic tools for mass spectrometry imaging}

\author{Kyle D. Bemis}

\begin{document}
\SweaveOpts{concordance=TRUE}

\maketitle

\tableofcontents

\section{Introduction}

<<echo=FALSE,results=hide>>=
options(width=69)
library(Cardinal)
options(Cardinal.verbose=FALSE)
options(Cardinal.progress=FALSE)
@ 
This will be a brief walkthrough of some of the basic functionality of Cardinal.

\section{Input/Output}
\subsection{Input}
\Rpackage{Cardinal} can read two of the most common data exchange formats in imaging mass spectrometry: Analyze 7.5 and imzML.

\subsubsection{Analyze 7.5}

Originally designed for MRI data by the Mayo Clinic, Analyze 7.5 is a common format used for exchange of mass spectrometry imaging data.

The Analyze format uses a collection of three files with extensions `.hdr', `.img', and `.t2m' for store data. All three files must be present in the same folder and have the same name (except for the file extension) for the data to be read properly.

To read datasets stored in the Analyze format, use the \verb|readAnalyze| function.

<<eval=FALSE>>=
name <- "This is the common name of your .hdr, .img, and .t2m files"
folder <- "/This/is/the/path/to/the/folder/containing/the/files"
data <- readAnalyze(name, folder)
@

For more information on reading Analyze files, type \verb|?readAnalyze|.

\subsubsection{imzML}

A more recently-developed format specifically designed for interchange of mass spectrometry imaging datasets, imzML is an open XML-based format to which many other formats can be converted.

The imzML format uses two files with extensions `.imzML' and `.ibd' to store data. Both files must be present in the same folder and have the same name (again, except for the file extension) for the data to be read properly.

To read datasets stored in the imzML format, use the \verb|readImzML| function.

<<eval=FALSE>>=
name <- "This is the common name of your .imzML and .ibd files"
folder <- "/This/is/the/path/to/the/folder/containing/the/files"
data <- readImzML(name, folder)
@

For more information on reading imzML files, type \verb|?readImzML|.

\subsubsection{readMSIData}

\Rpackage{Cardinal} also provides the convenience function \verb|readMSIData|, which can automatically recognize the data format based on the extension. The same rules as above about naming conventions applies, but one need only provide the path to any of the data files. For example, to read an Analyze file, providing the path to any of the `.hdr', `.img', or `.t2m' will work. Likewise, providing the path to either the `.imzML' or `.ibd' file will work for reading data stored in the imzML format.

<<eval=FALSE>>=
file <- "/This/is/the/path/to/an/imaging/data/file.extension"
data <- readMSIData(file)
@

\subsection{Output}

\subsubsection{RData files}

Any R object including those created by \Rpackage{Cardinal} can be saved as an \textbf{RData} file using the \verb|save| and loaded using the \verb|load| function.

<<eval=FALSE>>=
save(data, file="/Where/to/save/the/data.RData")
load("/Where/to/save/the/data.RData")
@

These functions are part of \R. See \verb|?save| and \verb|?load| for more details.

\section{Data exploration and visualization}

Mass spectrometry imaging datasets in \Rpackage{Cardinal} are stored in \Robject{MSImageSet} objects.

\textit{Technical note: \Robject{MSImageSet} is an S4 class. It inherits from the more general \Robject{SImageSet} class, which itself inherits from the \Robject{iSet} virtual class. The \Robject{iSet} virtual class is designed around the same design principles as the \Robject{eSet} class provided by \Rpackage{Biobase}. See the ``Cardinal development'' vignette for more information.}

\subsection{An example dataset}

For the sake of the following sections, we will create a simple simulated example dataset using the \Rpackage{Cardinal} function \verb|generateImage|.

<<>>=
set.seed(1)
pattern <- factor(c(0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 0,
	0, 0, 0, 0, 0, 0, 1, 2, 2, 0, 0, 0, 0, 0, 2, 1, 1, 2,
	2, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 0, 0, 0, 0, 1, 2, 2,
	2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2,
	2, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0),
	levels=c(0,1,2), labels=c("blue", "black", "red"))
msset <- generateImage(pattern, coord=expand.grid(x=1:9, y=1:9),
	range=c(1000, 5000), centers=c(2000, 3000, 4000),
	resolution=100, step=3.3, as="MSImageSet")
@

The above code creates a simulated MS imaging dataset \Robject{msset}, which is $9x9$ pixels, with a mass range from $m/z 1000$ to $m/z 5000$, with three peaks occurding at $m/z 2000$, $m/z 3000$, and $m/z 4000$, each corresponding to three distinct regions of interest (specified by our desired pattern).

(We'll call these regions of interest ``blue'', ``black'', and ``red'' for reasons that will become clear later. These are saved in the \textit{factor} \Robject{pattern}. A \textit{factor} is the standard way of storing categorical variables in \R.)

See \verb|?generateImage| for more details, or see the sections ``Advanced: Simulation of spectra'' and ``Advanced: Simulation of images''.

\subsection{The \Robject{MSImageSet} object}

Most important aspects of a mass spectrometry imaging dataset stored in an \Robject{MSImageSet} object can be accessed by simple methods.

For example, $m/z$-values are accessed by the method \verb|mz|, pixel coordinates are accessed by the method \verb|coord|, and the mass spectra themselves are accessed by the method \verb|spectra|. The mass spectra are stored as a matrix with each column corresponding to a mass spectrum

<<>>=
head(mz(msset), n=10) # first 10 m/z values
head(coord(msset), n=10) # first 10 pixel coordinates
head(spectra(msset)[,1], n=10) # first 10 intensities in the first mass spectrum
@

The methods \verb|nrow|, \verb|ncol|, \verb|dim|, and \verb|dims| can be used to retrive the dimensions of the dataset.

<<>>=
nrow(msset)
ncol(msset)
dim(msset)
dims(msset)
@

Two other helpful methods are \verb|features| and \verb|pixels|. These are useful for retrieving the feature \# and pixel \# (i.e., the row and column in the \Robject{spectra(msset)} matrix) corresponding to items of interest like specific $m/z$-values or pixel coordinates.

<<>>=
features(msset, mz=3000) # returns the feature most closely matching m/z 3000
pixels(msset, coord=list(x=5, y=5)) # returns the pixel for x = 5, y = 5
pixels(msset, x=5, y=5) # returns the pixel for x = 5, y = 5
@

See \verb|?MSImageSet| for more details and additional methods.

\subsection{Subsetting a \Robject{MSImageSet}}

A \Robject{MSImageSet} can be subset by row and column like an ordinary \R matrix or \textit{data.frame}, where rows correspond to the features ($m/z$-values) and columns correspond to pixels (locations associated with mass spectra). Subsetting will return a new \Robject{MSImageSet}.

For example, we can subset by $m/z$-values so that we only keep the mass range from $m/z 2500$ to $m/z 4500$.

<<>>=
tmp <- msset[2500 < mz(msset) & mz(msset) < 4500,]
range(mz(msset))
range(mz(tmp))
@

Alternatively, we can subset by pixel coordinates. To keep only pixels with $x$-coordinates greater than 5, we can do the following.

<<>>=
tmp <- msset[,coord(msset)$x >5]
range(coord(msset)$x)
range(coord(tmp)$x)
@

We can also subset in both ways at once.

<<>>=
tmp <- msset[2500 < mz(msset) & mz(msset) < 4500, coord(msset)$x >5]
range(mz(tmp))
range(coord(tmp)$x)
@

It is also possible to manually select a region of interest and use it to subset the dataset. This is done using the \verb|select| method, which will be introduced in the ``Plotting ion images'' section.

\subsection{Plotting mass spectra}

Mass spectra from an \Robject{MSImageSet} can be plotted using the \verb|plot| method.

<<plot1>>=
plot(msset, pixel=1)
@

<<plot2>>=
plot(msset, coord=list(x=5, y=5), plusminus=2)
@

<<plot3>>=
mycol <- c("blue", "black", "red")
plot(msset, pixel=1:ncol(msset), pixel.groups=pattern, superpose=TRUE, key=TRUE, col=mycol)
@

\setkeys{Gin}{width=0.3\textwidth}
\begin{figure}
\begin{center}
\begin{tabular}{ccc}
<<fig=TRUE, echo=FALSE>>=
<<plot1>>
@
&
<<fig=TRUE, echo=FALSE>>=
<<plot2>>
@
&
<<fig=TRUE, echo=FALSE>>=
<<plot3>>
@
\end{tabular}
\caption{\small Plotting mass spectra.}
\end{center}
\end{figure}

\subsection{Plotting ion images}

Ion images from an \Robject{MSImageSet} can be plotted using the \verb|image| method.

<<image1>>=
image(msset, feature=1)
@

<<image2>>=
image(msset, mz=4000, plusminus=10)
@

<<image3>>=
mycol <- c("blue", "black", "red")
image(msset, mz=c(2000, 3000, 4000), col=mycol, superpose=TRUE)
@

<<image4>>=
mycol <- gradient.colors(100, start="white", end="blue")
image(msset, mz=2000, col.regions=mycol, contrast.enhance="suppress")
@

<<image5>>=
mycol <- gradient.colors(100, start="white", end="black")
image(msset, mz=3000, col.regions=mycol, smooth.image="gaussian")
@

<<image6>>=
msset2 <- msset[,pattern == "black" | pattern == "red"]
mycol <- gradient.colors(100, start="black", end="red")
image(msset2, mz=4000, col.regions=mycol)
@

\begin{figure}
\setkeys{Gin}{width=0.3\textwidth}
\begin{center}
\begin{tabular}{ccc}
<<fig=TRUE, echo=FALSE>>=
<<image1>>
@
&
<<fig=TRUE, echo=FALSE>>=
<<image2>>
@
&
<<fig=TRUE, echo=FALSE>>=
<<image3>>
@
\\
<<fig=TRUE, echo=FALSE>>=
<<image4>>
@
&
<<fig=TRUE, echo=FALSE>>=
<<image5>>
@
&
<<fig=TRUE, echo=FALSE>>=
<<image6>>
@
\end{tabular}
\caption{\small Plotting ion images.}
\end{center}
\end{figure}


\section{Pre-processing}

\setkeys{Gin}{width=\textwidth}
\begin{figure}
\begin{center}
\includegraphics{preprocessingRoughDraft.pdf}
\caption{\small Preprocessing steps}
\end{center}
\end{figure}


\subsection{Normalization}

Normalization is perhaps the most important pre-processing step before any kind of analysis should be performed on biological datasets, and mass spectrometry imaging experiments are no different in this regard. \Rpackage{Cardinal} provides normalization to total ion current (TIC). In the first command below, we only perform the normalization on the first pixel in order to show a plot of the processing results. In the second, we perform normalization on the whole dataset.
<<normalizetic>>=
temp <- normalize(msset, pixel=1, method="tic", plot=TRUE)
@
<<normalize>>=
msset2 <- normalize(msset, method="tic")
@
\setkeys{Gin}{width=0.4\textwidth}
\begin{figure}
\begin{center}
<<fig=TRUE, echo=FALSE>>=
<<normalizetic>>
@
\caption{\small Total ion current (TIC) normalization.}
\end{center}
\end{figure}

\subsection{Smoothing}

Smoothing the mass spectra is useful for removing noise, which can improve detection of peaks. \Rpackage{Cardinal} provides several common methods for smoothing mass spectra, including Gaussian kernel smoothing, Savitsky-Golay smoothing, and a simple moving average filter.
<<smoothgaus>>=
temp <- smoothSignal(msset2, pixel=1, method="gaussian", window=9, plot=TRUE)
@
<<smoothsgolay>>=
temp <- smoothSignal(msset2, pixel=1, method="sgolay", window=15, plot=TRUE)
@
<<smooth>>=
msset3 <- smoothSignal(msset2, method="gaussian", window=9)
@
\begin{figure}
\setkeys{Gin}{width=0.4\textwidth}
\begin{center}
\begin{tabular}{ccc}
<<fig=TRUE, echo=FALSE>>=
<<smoothgaus>>
@
&
<<fig=TRUE, echo=FALSE>>=
<<smoothsgolay>>
@
\end{tabular}
\caption{\small Gaussian smoothing and Savitsky-Golay smoothing.}
\end{center}
\end{figure}

\subsection{Baseline reduction}

Baseline reduction is often necessary for many datasets, and \Rpackage{Cardinal} implements a simple version that interpolates a baseline from local medians or local minima, while attempting to preserve the signal from mass spectral peaks.
<<baselinemedian>>=
temp <- reduceBaseline(msset3, pixel=1, method="median", blocks=50, plot=TRUE)
@
<<baseline>>=
msset4 <- reduceBaseline(msset3, method="median", blocks=50)
@
\setkeys{Gin}{width=0.4\textwidth}
\begin{figure}
\begin{center}
<<fig=TRUE, echo=FALSE>>=
<<baselinemedian>>
@
\caption{\small Baseline reduction using interpolation from medians.}
\end{center}
\end{figure}

\subsection{Peak picking}

Peak picking is a common form of data reduction that reduces the signal to relevant data peaks. \Rpackage{Cardinal} implements three varieties based on a user-specified signal-to-noise ratio (SNR). The ``simple'' version interpolates a constant noise pattern, the ``adaptive'' version interpolates an adaptive noise pattern, and ``limpic'' implements the LIMPIC algorithm for peak detection.
<<peakpickadaptive>>=
temp <- peakPick(msset4, pixel=1, method="adaptive", SNR=3, plot=TRUE)
@
<<peakpicklimpic>>=
temp <- peakPick(msset4, pixel=1, method="limpic", SNR=3, plot=TRUE)
@
<<peakpick>>=
msset5 <- peakPick(msset4, method="simple", SNR=3)
@
\begin{figure}
\setkeys{Gin}{width=0.4\textwidth}
\begin{center}
\begin{tabular}{cc}
<<fig=TRUE, echo=FALSE>>=
<<peakpickadaptive>>
@
&
<<fig=TRUE, echo=FALSE>>=
<<peakpicklimpic>>
@
\end{tabular}
\caption{\small Peak picking with adaptive noise and LIMPIC.}
\end{center}
\end{figure}

\subsection{Peak alignment}

Peak alignment is necessary to account for possible inaccuracy in m/z measurements. Peaks can be aligned to a reference list of known m/z values, or to the local maxima in the mean spectrum.
<<peakaligndiff>>=
temp <- peakAlign(msset5, pixel=1, method="diff", plot=TRUE)
@
<<peakalign>>=
msset6 <- peakAlign(msset5, method="diff")
@
\setkeys{Gin}{width=0.4\textwidth}
\begin{figure}
\begin{center}
<<fig=TRUE, echo=FALSE>>=
<<peakaligndiff>>
@
\caption{\small Peak alignment to the local maxima of the mean spectrum.}
\end{center}
\end{figure}

\subsection{Data reduction}

Other common forms of data reduction include resampling and binning.
<<reducedimbin>>=
temp <- reduceDimension(msset4, pixel=1, method="bin", width=25, fun=mean, plot=TRUE)
@
<<reducedimresample>>=
temp <- reduceDimension(msset4, pixel=1, method="resample", step=25, plot=TRUE)
@
<<reducedim>>=
msset7 <- reduceDimension(msset4, method="resample", step=25)
@
\begin{figure}
\setkeys{Gin}{width=0.4\textwidth}
\begin{center}
\begin{tabular}{cc}
<<fig=TRUE, echo=FALSE>>=
<<reducedimbin>>
@
&
<<fig=TRUE, echo=FALSE>>=
<<reducedimresample>>
@
\end{tabular}
\caption{\small Data reduction via binning and resampling.}
\end{center}
\end{figure}





\section{Analysis}


\section{Advanced Topics}

\subsection{Apply}
The \verb|apply| family of functions are a powerful feature of \R. The \verb|apply| function applies a function over margins of an array, while \verb|sapply| applies a function over every element of a vector-like object. The function \verb|tapply| applies a function over a ``ragged'' array, so that the function is applied over groups of values given by levels of another variable (usually a factor). In \Rpackage{Cardinal}, the methods \verb|pixelApply| and \verb|featureApply| allow \verb|apply|-like functionality that combine traits of each of these, tailored for imaging datasets.

For the following examples, we will use a simulated dataset. The image is a cardinal with red and black feathers, where the colors represent different regions of the image. The mass spectra will have two peaks to indicate the two regions. We use \Robject{generateImage} to generate the dataset from an integer matrix where $0$ represents black regions of the image and $1$ represents the red regions of the image.
<<data>>=
data <- matrix(c(NA, NA, 1, 1, NA, NA, NA, NA, NA, NA, 1, 1, NA, NA, 
 NA, NA, NA, NA, NA, 0, 1, 1, NA, NA, NA, NA, NA, 1, 0, 0, 1, 
 1, NA, NA, NA, NA, NA, 0, 1, 1, 1, 1, NA, NA, NA, NA, 0, 1, 1, 
 1, 1, 1, NA, NA, NA, NA, 1, 1, 1, 1, 1, 1, 1, NA, NA, NA, 1, 
 1, NA, NA, NA, NA, NA, NA, 1, 1, NA, NA, NA, NA, NA), nrow=9, ncol=9)
@
We can plot the ground truth image directly.
<<truth>>=
image(data[,ncol(data):1], col=c("black", "red"))
@
\setkeys{Gin}{width=0.4\textwidth}
\begin{figure}
\begin{center}
<<fig=TRUE, echo=FALSE>>=
<<truth>>
@
\caption{\small Ground truth image used to generate the simulated dataset.}
\end{center}
\end{figure}
Now we generate the data as if from a mass spectrometry imaging experiment with peaks at $m/z$ 3000 (higher intensity in black pixels) and $m/z$ 4000 (higher intensity in red pixels).
<<sim>>=
set.seed(1)
msset <- generateImage(data, range=c(1000,5000), centers=c(3000,4000), resolution=100,
  step=3.3, as="MSImageSet")
@
We need to mark which pixels are black and which are red.
<<pData>>=
pData(msset)$pg <- factor(data[is.finite(data)], labels=c("black", "red"))
@
Then we need to mark which features (which regions of the mass spectrum) belong to the peaks associated with ``black'' or ``red'' pixels; the rest of the spectrum is marked as background noise (\texttt{bg}).
<<fData>>=
fData(msset)$fg <- factor(rep("bg", nrow(fData(msset))), levels=c("bg", "black", "red"))
fData(msset)$fg[2950 < fData(msset)$mz & fData(msset)$mz < 3050] <- "black"
fData(msset)$fg[3950 < fData(msset)$mz & fData(msset)$mz < 4050] <- "red"
@
Now we can experiment with different ways of plotting an imaging dataset.

\subsubsection{\Robject{pixelApply}}

The method \verb|pixelApply| allows functions to be applied over all pixels. The function is applied pixel-by-pixel to the feature vectors (mass spectra). Here, we use \verb|pixelApply| to find the pixel-by-pixel mean intensity of different regions of the mass spectrum. We provide \verb|fData(msset)$fg| as a grouping variable, since it indicates different regions of the mass spectrum we expect to be associated with either background noise, or red or black pixels. Since \verb|pixelApply| knows to look in \Robject{msset} for the variable, we only need to provide \Robject{fg} to the argument \Robject{.feature.groups}.

<<pixelApply1, results=verbatim>>=
p1 <- pixelApply(msset, mean, .feature.groups=fg)
p1[,1:30]
@
By comparing side-by-side with the ground truth (which we have stored in the variable \verb|pData(msset)$pg|), we see the result is as we expected. For ``black'' pixels, the mean intensity of features belonging to the ``black''-associated peak ($m/z$ 3000) is higher, while for the ``red'' pixels, the mean intensity of features belonging to the ``red''-associated peak ($m/z$ 4000) is higher.
<<pixelApply2, results=verbatim>>=
cbind(pData(msset), t(p1))[1:30,c("pg", "black", "red")]
@
We can manually construct the images corresponding to the mean intensity of the two peaks centered at $m/z$ 3000 and $m/z$ 4000 and plot their images.
<<pixelApply3>>=
temp1 <- MSImageSet(spectra=t(as.vector(p1["black",])), coord=coord(msset), mz=3000)
image(temp1, feature=1, col=alpha.colors(100, "black"), main="black peak", sub="m/z = 3000")
@
<<pixelApply4>>=
temp2 <- MSImageSet(spectra=t(as.vector(p1["red",])), coord=coord(msset), mz=4000)
image(temp2, feature=1, col=alpha.colors(100, "red"), main="red peak", sub="m/z = 4000")
@
\begin{figure}
\setkeys{Gin}{width=0.4\textwidth}
\begin{center}
\begin{tabular}{cc}
<<fig=TRUE, echo=FALSE>>=
<<pixelApply3>>
@
&
<<fig=TRUE, echo=FALSE>>=
<<pixelApply4>>
@
\end{tabular}
\caption{\small Mean intensites of the two peaks centered at $m/z$ 3000 and $m/z$ 4000.}
\end{center}
\end{figure}
If only the plots are desired rather than the actual data, then \verb|image| can be used to perform these steps automatically while producing the plot. See \textit{Cardinal plotting} for how to do this.

\subsubsection{\Robject{featureApply}}

The method \verb|featureApply| allows functions to be applied over all features. The function is applied to the flattened false-image vectors. The vectors are the pixel intensities of a single-feature image, disregarding missing pixels. Here, we use \verb|featureApply| to find the mean spectrum for different groups of pixels. We provide \verb|pData(msset)$pg| as a grouping variable, since it indicates the kind of pixel. We desire a mean spectrum for the black pixels and a mean spectrum for the red pixels. As before, since \verb|featureApply| knows to look in \Robject{msset}, we only need to provide \Robject{pg} to the argument \Robject{.pixel.groups}.
<<featureApply1>>=
f1 <- featureApply(msset, mean, .pixel.groups=pg)
f1[,1:30]
@
Again, we can check the results by plotting them.
<<featureApply2>>=
plot(mz(msset), f1["black",], type="l", xlab="m/z", ylab="Intensity", main="mean spectrum of black pixels", col="black")
@
<<featureApply3>>=
plot(mz(msset), f1["red",], type="l", xlab="m/z", ylab="Intensity", main="mean spectrum of red pixels", col="red")
@
\begin{figure}
\setkeys{Gin}{width=0.4\textwidth}
\begin{center}
\begin{tabular}{cc}
<<fig=TRUE, echo=FALSE>>=
<<featureApply2>>
@
&
<<fig=TRUE, echo=FALSE>>=
<<featureApply3>>
@
\end{tabular}
\caption{\small Mean intensites of the two peaks centered at $m/z$ 3000 and $m/z$ 4000.}
\end{center}
\end{figure}
As expected, we see the mean spectrum of the black pixels has a higher peak at $m/z$ 3000 while the mean spectrum of the red pixels has a higher peak at $m/z$ 4000. As before, if only the plots are desired rather than the actual data, then \verb|plot| can be used to perform these steps automatically. See \textit{Cardinal plotting} for how to do this.


\subsection{Simulation}





\section{Session info}




<<results=tex, echo=FALSE>>=
toLatex(sessionInfo())
@

\end{document}
